Basic SPI Data Transfer using FPGA (Verilog)
1. Project Overview

This mini project implements basic SPI (Serial Peripheral Interface) communication entirely in Verilog HDL, verified through simulation in Vivado.

The FPGA acts as an SPI Master

A Dummy SPI Slave is modeled in Verilog

No external hardware or SPI device is required

The design demonstrates SPI Mode-0 communication, bit-wise serial data transfer, and protocol timing

The project is intended as a learning-oriented implementation of SPI, focusing on how SPI works internally, rather than on advanced peripherals.

2. Project Objective

âœ” Transmit one byte (0xA5) from SPI Master

âœ” Receive one byte (0x3C) from SPI Slave

âœ” Verify received data

âœ” Indicate result using PASS / FAIL signal

âœ” Observe all SPI signals in simulation

3. SPI Configuration

| Parameter    | Value                       |
| ------------ | --------------------------- |
| SPI Mode     | Mode 0                      |
| CPOL         | 0 (Clock idle LOW)          |
| CPHA         | 0 (Sample on rising edge)   |
| Data Order   | MSB first                   |
| Data Width   | 8 bits                      |
| Transaction  | Single-byte transfer        |
| Clock Source | FPGA system clock (100 MHz) |

4. Project Architecture


+-------------+        SPI Bus        +------------------+
| SPI Master  |----------------------| Dummy SPI Slave  |
|   (FPGA)    |  SCLK, CS, MOSI, MISO|   (Verilog)     |
+-------------+                      +------------------+


5. File Structure

SPI_MODULATION/
â”‚
â”œâ”€â”€ spi_master.v        # SPI Master implementation
â”œâ”€â”€ spi_slave_dummy.v  # Dummy SPI Slave implementation
â”œâ”€â”€ spi_top.v           # Top-level integration
â”œâ”€â”€ tb_spi_top.v        # Testbench for simulation
â””â”€â”€ README.md

Detailed File Descriptions & Code Explanation

1ï¸âƒ£ spi_master.v â€” SPI Master Module


ğŸ”¹ Purpose

This module implements the SPI Master logic, responsible for:

.Generating SPI Clock (SCLK)

.Controlling Chip Select (CS)

.Transmitting data on MOSI

.Receiving data from MISO

.Managing SPI timing (Mode-0)

ğŸ”¹ Functional Overview

1. Waits for start signal

2. Pulls CS LOW to select slave

3. Generates SCLK

4. Shifts out data bit-by-bit on MOSI

5. Samples incoming bits from MISO

6. Completes transfer and raises done

ğŸ”¹ Important Internal Signals

| Signal     | Description                   |
| ---------- | ----------------------------- |
| `tx_data`  | Byte to transmit (`0xA5`)     |
| `rx_data`  | Byte received from slave      |
| `tx_shift` | Transmit shift register       |
| `rx_shift` | Receive shift register        |
| `bit_cnt`  | Counts transmitted bits (0â€“7) |
| `sclk`     | SPI clock generated by master |
| `cs`       | Active-LOW chip select        |
| `mosi`     | Master Out Slave In           |
| `miso`     | Master In Slave Out           |

ğŸ”¹ SPI Timing (Mode 0)

SCLK idle LOW

MOSI changes on falling edge

MISO sampled on rising edge

ğŸ”¹ Data Shifting Mechanism

Transmit (MOSI):
mosi <= tx_shift[7];   // Send MSB first
tx_shift <= {tx_shift[6:0], 1'b0};

Receive (MISO):
rx_shift <= {rx_shift[6:0], miso};

ğŸ”¹ End of Transfer:
After 8 clock cycles:
cs is de-asserted (HIGH)
rx_data is latched
done signal is asserted

2ï¸âƒ£ spi_slave_dummy.v â€” Dummy SPI Slave Module

ğŸ”¹ Purpose

This module simulates a simple SPI Slave that:

Does not generate clock

Responds only when CS is LOW

Sends a fixed byte (0x3C)

Ignores MOSI data (for simplicity)

ğŸ”¹ Why Dummy Slave?

âœ” Allows SPI verification without hardware

âœ” Ideal for understanding SPI timing

âœ” Simplifies debugging and learning

ğŸ”¹ Slave Behavior

1. Detects CS LOW

2. Loads fixed response (0x3C)

3. Shifts data out on falling edge of SCLK

4. Drives data on MISO

ğŸ”¹ Key Design Rule Followed

SPI Slave never generates clock â€” only responds to master clock

ğŸ”¹ Shift Register Logic 

miso <= slave_shift[7];
slave_shift <= {slave_shift[6:0], 1'b0};

3ï¸âƒ£ spi_top.v â€” Top-Level Module

ğŸ”¹ Purpose

This module connects everything together:

Instantiates SPI Master

Instantiates Dummy SPI Slave

Automatically starts SPI transaction

Compares received data

Generates PASS / FAIL output

ğŸ”¹ Functional Flow

1. Reset applied

2. SPI transfer automatically starts

3. Master sends 0xA5

4. Slave responds with 0x3C

5. Received data is checked

6. PASS or FAIL is asserted

ğŸ”¹ Data Verification Logic

if (rx_data == 8'h3C)
    pass <= 1'b1;
else
    fail <= 1'b1;

ğŸ”¹ Why a Top Module?

âœ” Central control

âœ” Clean integration

âœ” Easy FPGA mapping

âœ” Easier testbench design


4ï¸âƒ£ tb_spi_top.v â€” Testbench

ğŸ”¹ Purpose

The testbench verifies the entire SPI system in simulation.

ğŸ”¹ What the Testbench Does

âœ” Generates 100 MHz FPGA clock

âœ” Applies reset

âœ” Observes SPI signals

âœ” Displays PASS / FAIL

âœ” Enables waveform analysis

ğŸ”¹ Simulation Observation:

 we run the simulation on vivado and get the result like:
 
 ![alt text](image.png)

 ğŸ” Step-by-Step Data Flow (End-to-End)

1ï¸âƒ£ Reset asserted

2ï¸âƒ£ SPI Master initializes

3ï¸âƒ£ CS pulled LOW

4ï¸âƒ£ SPI clock starts

5ï¸âƒ£ MOSI transmits 10100101

6ï¸âƒ£ Slave shifts out 00111100

7ï¸âƒ£ Master samples MISO on rising edge

8ï¸âƒ£ After 8 bits, transfer ends

9ï¸âƒ£ Received data compared

ğŸ”Ÿ PASS / FAIL generated

ğŸ”¹Key Learnings

SPI protocol fundamentals

CPOL / CPHA timing

Serial-to-parallel conversion

Shift-register based communication

FPGA protocol modeling

Simulation-based verification

ğŸ”¹Tools Used

Vivado Design Suite

Verilog HDL

Vivado Waveform Viewer / GTKWave

ğŸ‘¥ Contributors

ğŸ”¹ Ujwal

Role: Top Module Integration & Verification

Designed the Top module

Integrated SPI Master and SPI Slave

Implemented automatic SPI start after reset

Compared transmitted and received data

Generated PASS / FAIL output

Developed the Testbench:

Generated FPGA clock

Applied reset

Observed SCLK, CS, MOSI, MISO

Verified SPI transfer in simulation

ğŸ”¹ Incharaa (https://github.com/IncharaaShivaprakash/IncharaaShivaprakash)

Role: SPI Master Design

Designed SPI Master

Implemented SCLK, CS, MOSI logic

Implemented shift registers

Ensured SPI Mode-0 compliance

Contribution: Designing and Implementation of SPI Master Module.
â— Designing SPI master logic in verilog HDL
â— Generating all SPI control signals: Serial Clock (SCLK), Chip Select (CS), Master out
slave in (MOSI)
â— Recieving data via the Master in slave out (MISO) line
â— Implementing shift register based serial data transmission and reception
â— Making sure of correct SPI Mode-0 (CPOL=0, CPHA = 0)
â— Handling transaction start, end and reset conditions

ğŸ”¹ Aradhya (https://github.com/aradhya101)

Role: SPI Slave Design

Designed Dummy SPI Slave

Implemented fixed response (0x3C)

Implemented MISO shift logic

Ensured correct slave timing

Learning Resources:

ğŸ”¹ Vivado installation and SetUp
1. https://www.youtube.com/watch?si=e_4kKj7fOBpXytX6&v=W8k0cfSOFbs&feature=youtu.be
2. https://www.youtube.com/watch?v=-U1OzeV9EKg
3. https://www.youtube.com/watch?v=bw7umthnRYw&feature=youtu.be
4. https://www.youtube.com/playlist?list=PLmLQnr2Fjat0WpVSmZ76kkMtSWie2DBpQ

SPI related Resources

1. https://youtu.be/AV0w0Ko7D6E?si=LeWXZZPq2TrwtU3f (For SPI basics, part 1)
2. https://youtu.be/3EtKfSIJADw?si=VlOuTJDha0-j72hh (For SPI basics, part 2)
3. https://www.youtube.com/watch?v=hiCm95SieSE (SPI basics+code implementation+testbench)
4. https://youtube.com/playlist?list=PL-rm6ajteTiSzUBOgbqTFRMXgwaX5Jq3M&si=yhsXUoZ1UEr1oIpy (Playlist for SPI communication)
5. https://www.youtube.com/playlist?list=PLnAoag7Ew-vq5kOyfyNN50xL718AtLoCQ (SPI based playlist with emphasis on Verilog implementation)


