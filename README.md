Basic SPI Data Transfer using FPGA (Verilog)
1. Project Overview

This mini project implements basic SPI (Serial Peripheral Interface) communication entirely in Verilog HDL, verified through simulation in Vivado.

The FPGA acts as an SPI Master

A Dummy SPI Slave is modeled in Verilog

No external hardware or SPI device is required

The design demonstrates SPI Mode-0 communication, bit-wise serial data transfer, and protocol timing

The project is intended as a learning-oriented implementation of SPI, focusing on how SPI works internally, rather than on advanced peripherals.

2. Project Objective

‚úî Transmit one byte (0xA5) from SPI Master
‚úî Receive one byte (0x3C) from SPI Slave
‚úî Verify received data
‚úî Indicate result using PASS / FAIL signal
‚úî Observe all SPI signals in simulation

3. SPI Configuration

| Parameter    | Value                       |
| ------------ | --------------------------- |
| SPI Mode     | Mode 0                      |
| CPOL         | 0 (Clock idle LOW)          |
| CPHA         | 0 (Sample on rising edge)   |
| Data Order   | MSB first                   |
| Data Width   | 8 bits                      |
| Transaction  | Single-byte transfer        |
| Clock Source | FPGA system clock (100 MHz) |

4. Project Architecture



+-------------+        SPI Bus        +------------------+
| SPI Master  | ---------------------| Dummy SPI Slave  |
|   (FPGA)    |  SCLK, CS, MOSI, MISO |   (Verilog)     |
+-------------+                      +------------------+
                  |
                  |
               PASS / FAIL

5. File Structure

SPI_MODULATION/
‚îÇ
‚îú‚îÄ‚îÄ spi_master.v        # SPI Master implementation
‚îú‚îÄ‚îÄ spi_slave_dummy.v  # Dummy SPI Slave implementation
‚îú‚îÄ‚îÄ spi_top.v           # Top-level integration
‚îú‚îÄ‚îÄ tb_spi_top.v        # Testbench for simulation
‚îî‚îÄ‚îÄ README.md

Detailed File Descriptions & Code Explanation

1Ô∏è‚É£ spi_master.v ‚Äî SPI Master Module


üîπ Purpose

This module implements the SPI Master logic, responsible for:

.Generating SPI Clock (SCLK)

.Controlling Chip Select (CS)

.Transmitting data on MOSI

.Receiving data from MISO

.Managing SPI timing (Mode-0)

üîπ Functional Overview

1. Waits for start signal

2. Pulls CS LOW to select slave

3. Generates SCLK

4. Shifts out data bit-by-bit on MOSI

5. Samples incoming bits from MISO

6. Completes transfer and raises done

üîπ Important Internal Signals

| Signal     | Description                   |
| ---------- | ----------------------------- |
| `tx_data`  | Byte to transmit (`0xA5`)     |
| `rx_data`  | Byte received from slave      |
| `tx_shift` | Transmit shift register       |
| `rx_shift` | Receive shift register        |
| `bit_cnt`  | Counts transmitted bits (0‚Äì7) |
| `sclk`     | SPI clock generated by master |
| `cs`       | Active-LOW chip select        |
| `mosi`     | Master Out Slave In           |
| `miso`     | Master In Slave Out           |

üîπ SPI Timing (Mode 0)

SCLK idle LOW

MOSI changes on falling edge

MISO sampled on rising edge

üîπ Data Shifting Mechanism

Transmit (MOSI):
mosi <= tx_shift[7];   // Send MSB first
tx_shift <= {tx_shift[6:0], 1'b0};

Receive (MISO):
rx_shift <= {rx_shift[6:0], miso};

üîπ End of Transfer:
After 8 clock cycles:
cs is de-asserted (HIGH)
rx_data is latched
done signal is asserted

2Ô∏è‚É£ spi_slave_dummy.v ‚Äî Dummy SPI Slave Module
üîπ Purpose

This module simulates a simple SPI Slave that:

Does not generate clock

Responds only when CS is LOW

Sends a fixed byte (0x3C)

Ignores MOSI data (for simplicity)

üîπ Why Dummy Slave?

‚úî Allows SPI verification without hardware
‚úî Ideal for understanding SPI timing
‚úî Simplifies debugging and learning

üîπ Slave Behavior

1. Detects CS LOW

2. Loads fixed response (0x3C)

3. Shifts data out on falling edge of SCLK

4. Drives data on MISO

üîπ Key Design Rule Followed

SPI Slave never generates clock ‚Äî only responds to master clock

üîπ Shift Register Logic 

miso <= slave_shift[7];
slave_shift <= {slave_shift[6:0], 1'b0};

3Ô∏è‚É£ spi_top.v ‚Äî Top-Level Module
üîπ Purpose

This module connects everything together:

Instantiates SPI Master

Instantiates Dummy SPI Slave

Automatically starts SPI transaction

Compares received data

Generates PASS / FAIL output

üîπ Functional Flow

1. Reset applied

2. SPI transfer automatically starts

3. Master sends 0xA5

4. Slave responds with 0x3C

5. Received data is checked

6. PASS or FAIL is asserted

üîπ Data Verification Logic

if (rx_data == 8'h3C)
    pass <= 1'b1;
else
    fail <= 1'b1;

üîπ Why a Top Module?

‚úî Central control
‚úî Clean integration
‚úî Easy FPGA mapping
‚úî Easier testbench design

4Ô∏è‚É£ tb_spi_top.v ‚Äî Testbench
üîπ Purpose

The testbench verifies the entire SPI system in simulation.

üîπ What the Testbench Does

‚úî Generates 100 MHz FPGA clock
‚úî Applies reset
‚úî Observes SPI signals
‚úî Displays PASS / FAIL
‚úî Enables waveform analysis

üîπ Simulation Observation:
 we run the simulation on vivado and get the result like:
 ![alt text](image.png)

 üîÅ Step-by-Step Data Flow (End-to-End)

1Ô∏è‚É£ Reset asserted

2Ô∏è‚É£ SPI Master initializes

3Ô∏è‚É£ CS pulled LOW

4Ô∏è‚É£ SPI clock starts

5Ô∏è‚É£ MOSI transmits 10100101

6Ô∏è‚É£ Slave shifts out 00111100

7Ô∏è‚É£ Master samples MISO on rising edge

8Ô∏è‚É£ After 8 bits, transfer ends

9Ô∏è‚É£ Received data compared

üîü PASS / FAIL generated

üîπKey Learnings

SPI protocol fundamentals

CPOL / CPHA timing

Serial-to-parallel conversion

Shift-register based communication

FPGA protocol modeling

Simulation-based verification

üîπTools Used

Vivado Design Suite

Verilog HDL

Vivado Waveform Viewer / GTKWave

üë• Contributors

üîπ Ujwal

üîπ Ujwal

Role: Top Module Integration & Verification

Designed the Top module

Integrated SPI Master and SPI Slave

Implemented automatic SPI start after reset

Compared transmitted and received data

Generated PASS / FAIL output

Developed the Testbench:

Generated FPGA clock

Applied reset

Observed SCLK, CS, MOSI, MISO

Verified SPI transfer in simulation

üîπ Incharaa (https://github.com/IncharaaShivaprakash/IncharaaShivaprakash)

Role: SPI Master Design

Designed SPI Master

Implemented SCLK, CS, MOSI logic

Implemented shift registers

Ensured SPI Mode-0 compliance

Contribution: Designing and Implementation of SPI Master Module.
‚óè Designing SPI master logic in verilog HDL
‚óè Generating all SPI control signals: Serial Clock (SCLK), Chip Select (CS), Master out
slave in (MOSI)
‚óè Recieving data via the Master in slave out (MISO) line
‚óè Implementing shift register based serial data transmission and reception
‚óè Making sure of correct SPI Mode-0 (CPOL=0, CPHA = 0)
‚óè Handling transaction start, end and reset conditions

üîπ Aradhya (https://github.com/aradhya101)

Role: SPI Slave Design

Designed Dummy SPI Slave

Implemented fixed response (0x3C)

Implemented MISO shift logic

Ensured correct slave timing

Learning Resources:

üîπ Vivado installation and SetUp
1. https://www.youtube.com/watch?si=e_4kKj7fOBpXytX6&v=W8k0cfSOFbs&feature=youtu.be
2. https://www.youtube.com/watch?v=-U1OzeV9EKg
3. https://www.youtube.com/watch?v=bw7umthnRYw&feature=youtu.be
4. https://www.youtube.com/playlist?list=PLmLQnr2Fjat0WpVSmZ76kkMtSWie2DBpQ

SPI related Resources

1. https://youtu.be/AV0w0Ko7D6E?si=LeWXZZPq2TrwtU3f (For SPI basics, part 1)
2. https://youtu.be/3EtKfSIJADw?si=VlOuTJDha0-j72hh (For SPI basics, part 2)
3. https://www.youtube.com/watch?v=hiCm95SieSE (SPI basics+code implementation+testbench)
4. https://youtube.com/playlist?list=PL-rm6ajteTiSzUBOgbqTFRMXgwaX5Jq3M&si=yhsXUoZ1UEr1oIpy (Playlist for SPI communication)
5. https://www.youtube.com/playlist?list=PLnAoag7Ew-vq5kOyfyNN50xL718AtLoCQ (SPI based playlist with emphasis on Verilog implementation)


